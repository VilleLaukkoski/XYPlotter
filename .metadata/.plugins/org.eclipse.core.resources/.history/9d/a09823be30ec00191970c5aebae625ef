/*
 ===============================================================================
 Name        : main.c
 Author      : $(author)
 Version     :
 Copyright   : $(copyright)
 Description : main definition
 ===============================================================================
 */

#if defined (__USE_LPCOPEN)
#if defined(NO_BOARD_LIB)
#include "chip.h"
#else
#include "board.h"
#endif
#endif
#include <cr_section_macros.h>
#include <vector>
#include "DigitalIoPin.h"
#include "Fmutex.h"
#include "Motor.h"
#include "swm_15xx.h"
// TODO: insert other include files here

// TODO: insert other definitions and declarations here
#include "FreeRTOS.h"
#include "task.h"
#include <string>
#include "Parser.h"
using namespace std;

SemaphoreHandle_t xMotorStop = 0;
SemaphoreHandle_t yMotorStop = 0;
//void parser(string line);
//float* getSpot(float curX, float curY, float X, float Y);
void sendData(vector<string> lineParts);

float LastY = 0;
float LastX = 0;
int fDutyCycl = 1500;

Motor *X;
Motor *Y;
Parser parser;

int sign(int x) {
	if(x>0) return 1;

	else if(x<0) return -1;

	else return 0;
}
void bres(int sdx, int sdy) {
	int dx = abs(sdx);
	int dy = abs(sdy);
	int swap = 0;
	int temp;
	int s1=sign(sdx);
	int s2=sign(sdy);
	int p;
	int i =0;
	int size;


	if(dy >= dx){
		size = dy;
	} else{
		size = dx;
		}
	int iTabX[size] = { 0 };	//why not dx and dy?
	int iTabY[size] = { 0 };

/*	for(int iCpt =0; iCpt < size; iCpt++){
		iTabX[iCpt]=0;
		iTabY[iCpt]=0;
	}

	if(dy>dx) {		for( i=0; i<dx; i++ ) {
		temp=dx;
		dx=dy;
		dy=temp;
		swap=1;
	}
*/
	if (dy >= dx){
		temp = dy;
	}else {
		temp = dx;
	}

	p = 2*dy-dx;
	for( i = 0; i<temp; i++ ) {
		while(p >= 0) {
			p=p-2*dx;

			if(swap == 1) iTabX[i] =s1;

			else iTabY[i] =s2;
		}
		p = p+2*dy;

		if(swap == 1) iTabY[i] =s2;

		else iTabX[i] =s1;

		if(iTabX[i] != 0){
			DEBUGOUT("X-Move\r\n");
			X->move(iTabX[i] ==1);
		}
		if(iTabY[i] != 0){
			DEBUGOUT("Y-Move\r\n");
			Y->move(iTabY[i] ==1);
		}
	}
}

void SCT_Init(void) {

	Chip_SCT_Init(LPC_SCT0);
	Chip_SWM_MovablePortPinAssign(SWM_SCT0_OUT0_O, 0, 10);
	DEBUGOUT("SCT_Init \r\n");
	LPC_SCT0->CONFIG        |= (1 << 17);                // two 16-bit timers, auto limit
	LPC_SCT0->CTRL_L        |= (72-1) << 5;              // set prescaler, SCTimer/PWM clock = 1 MHz
	LPC_SCT0->MATCHREL[0].L  = 2000;                     // match 0 @ 1000/1MHz = 1 msec (1 kHz PWM freq)
	LPC_SCT0->MATCHREL[1].L  = 1500;                        // match 1 used for duty cycle (in 10 steps)

	LPC_SCT0->EVENT[0].STATE = 0xFFFFFFFF;               // event 0 happens in all states
	LPC_SCT0->EVENT[0].CTRL  = (1 << 12);                // match 0 condition only

	LPC_SCT0->EVENT[1].STATE = 0xFFFFFFFF;               // event 1 happens in all states
	LPC_SCT0->EVENT[1].CTRL  = (1 << 0) | (1 << 12);     // match 1 condition only

	LPC_SCT0->OUT[0].SET     = (1 << 0);                 // event 0 will set   SCTx_OUT0
	LPC_SCT0->OUT[0].CLR     = (1 << 1);                 // event 1 will clear SCTx_OUT0

	LPC_SCT0->CTRL_L        &= ~(1 << 2);                // unhalt it by clearing bit 2 of CTRL reg }
}

static void prvSetupHardware(void) {
	SystemCoreClockUpdate();
	Board_Init();
	SCT_Init();
	/* Initial LED0 state is off */
	Board_LED_Set(0, false);
}

void sendData(vector<string> lineParts) {
	DigitalIoPin pen(0, 10, false, true, true);
	string inputCommand = lineParts[0];
	float coordinates[2];
	int speed = 0;
	int penPos = 0;
	int xTicks = 0;
	int yTicks = 0;


	if (inputCommand == "G1") { //Go to position. Coordinates are in millimetres. The last parameter tells is coordinates are relative or
		lineParts[1].erase(0, 1);	//absolute (A0 = absolute, A1 = relative)
		lineParts[2].erase(0, 1);
		DEBUGOUT("beforex: %d\r\n", stoi(lineParts[1]));
		DEBUGOUT("beforeY: %d\r\n", stoi(lineParts[2]));
		coordinates[0] = stof(lineParts[1]);
		coordinates[1] = stof(lineParts[2]);

		bool dirX = coordinates[0] > LastX ? false : true;
		bool dirY = coordinates[1] > LastY ? false : true;
		vTaskDelay(100);
		xTicks = abs(coordinates[0] - LastX);
		yTicks = abs(coordinates[1] - LastY);
		bres(xTicks, yTicks);
//		X->move(xTicks, dirX);
//		Y->move(yTicks, dirY);

		LastX = coordinates[0];
		LastY = coordinates[1];

	} else if (inputCommand == "M1") {	//Set pen position (control servo). Range 0 - 255. Remember that servo pulse (high) length must be
		DEBUGOUT ("M1 CALLED \r\n");

		DEBUGOUT("%d \r\n", stoi(lineParts[1]));
//		lineParts[1].erase(0, 1);// between 1 - 2 ms and pulse frequency is 50 Hz.
//		fDutyCycl = stoi(lineParts[1])/255;
		if (stoi(lineParts[1]) != 130){
			fDutyCycl = 1000;
		}
		else{
			fDutyCycl = 1500;
		}
	}
}

void PenTask( void * pvParameters ) {
	while (1){
		vTaskDelay(100);
		LPC_SCT0->MATCHREL[1].L = fDutyCycl;
	}
}

static void getData(void *pvParameters) {
	int r;
	string line;
	while (1) {
		r = Board_UARTGetChar();
		if (r != EOF) {
			if (r == '\n') {
				vTaskDelay(configTICK_RATE_HZ / 50);

				sendData(parser.parse(line));

				line.clear();
				Board_UARTPutSTR("OK\n");

			} else {
				line.push_back(r);
			}
		}
	}
}

/*
 float * getSpot(float curX, float curY, float X, float Y) {
 static float values[2];
 values[0] = curX - X;
 values[1] = curY - Y;
 if (values[0] < values[1]) {
 values[0] = values[1] / values[0];
 values[1] = 1;
 } else {
 values[1] = values[0] / values[1];
 values[0] = 1;
 }
 return values;
 }
 */

/* the following is required if runtime statistics are to be collected */
extern "C" {

void vConfigureTimerForRunTimeStats(void) {
	Chip_SCT_Init(LPC_SCTSMALL1);
	LPC_SCTSMALL1->CONFIG = SCT_CONFIG_32BIT_COUNTER;
	LPC_SCTSMALL1->CTRL_U = SCT_CTRL_PRE_L(255) | SCT_CTRL_CLRCTR_L; // set prescaler to 256 (255 + 1), and start timer
}

}

int main(void) {
	prvSetupHardware();
	Chip_RIT_Init(LPC_RITIMER);
	NVIC_SetPriority( RITIMER_IRQn, configMAX_SYSCALL_INTERRUPT_PRIORITY + 1 );


	xMotorStop = xSemaphoreCreateBinary();
	yMotorStop = xSemaphoreCreateBinary();
	DigitalIoPin laser (0, 12, false, true, true);
	laser.write(false);
	X = new Motor (0, 27, 1, 3, 0, 0, 1, 0);
	Y = new Motor (0, 24, 0, 9, 0, 29, 0, 28);

	xTaskCreate(getData, "getData",
	configMINIMAL_STACK_SIZE * 6, NULL, (tskIDLE_PRIORITY + 2UL),
			(TaskHandle_t *) NULL);
	xTaskCreate(PenTask, "penTask",
		configMINIMAL_STACK_SIZE * 2, NULL, (tskIDLE_PRIORITY + 2UL),
				(TaskHandle_t *) NULL);
	/* Start the scheduler */
	vTaskStartScheduler();

	/* Should never arrive here */
	return 1;
}
